/*
  Flatpoint Detail Page Scraper
  - Extracts full detail HTML, images, and specifications from product detail pages
  - Enhances existing JSON with rich detail data
*/

try { require('dotenv').config({ path: require('fs').existsSync('.env.local') ? '.env.local' : '.env' }); } catch {}

const fs = require('fs');
const path = require('path');
const { chromium } = require('playwright');

function absoluteUrl(u, base) {
  try { return new URL(u, base).toString(); }
  catch { return null; }
}

async function scrapeDetailPage(page, productUrl) {
  console.log(`\nüìÑ Scraping: ${productUrl}`);

  try {
    // Navigate to detail page
    await page.goto(productUrl, { waitUntil: 'domcontentloaded', timeout: 60000 });
    await page.waitForTimeout(2000); // Wait for dynamic content

    // Scroll to load lazy-loaded images
    await page.evaluate(async () => {
      await new Promise((resolve) => {
        let totalHeight = 0;
        const distance = 500;
        const timer = setInterval(() => {
          const scrollHeight = document.body.scrollHeight;
          window.scrollBy(0, distance);
          totalHeight += distance;

          if (totalHeight >= scrollHeight) {
            clearInterval(timer);
            resolve();
          }
        }, 200);
      });
    });

    // Wait for images to load
    await page.waitForTimeout(3000);

    // Trigger lazy-loading by replacing ec-data-src with src
    await page.evaluate(() => {
      const lazyImages = document.querySelectorAll('img[ec-data-src]');
      lazyImages.forEach(img => {
        const lazySrc = img.getAttribute('ec-data-src');
        if (lazySrc) {
          img.setAttribute('src', lazySrc);
        }
      });
    });

    await page.waitForTimeout(1000);

    // Extract detail data
    const detailData = await page.evaluate(() => {
      const result = {
        detailHTML: '',
        detailImages: [],
        specifications: {},
        description: '',
        rawText: '',
        styles: [],           // üÜï Ïä§ÌÉÄÏùº/Ïª¨Îü¨ ÏòµÏÖò
        series: [],           // üÜï ÏãúÎ¶¨Ï¶à Ï†ïÎ≥¥
        reviews: []           // üÜï Î¶¨Î∑∞ Ïù¥ÎØ∏ÏßÄ
      };

      // 1. Extract main detail content HTML (with replaced image URLs)
      const detailSection = document.querySelector('#prdDetail, #prdDetailContent, #prdDetailContentLazy, .pdp-detail, .detail, .prdDetail, .product-detail, .goods_detail');
      if (detailSection) {
        // Clone to avoid modifying the page
        const clone = detailSection.cloneNode(true);

        // Replace all ec-data-src with actual URLs
        const imgs = clone.querySelectorAll('img[ec-data-src]');
        imgs.forEach(img => {
          const lazySrc = img.getAttribute('ec-data-src');
          if (lazySrc) {
            img.setAttribute('src', lazySrc);
            img.removeAttribute('ec-data-src');
          }
        });

        result.detailHTML = clone.innerHTML.trim();
        result.rawText = detailSection.textContent.trim().replace(/\s+/g, ' ');
      }

      // 2. Extract all detail images
      const imageSelectors = [
        '.detail img',
        '.prdDetail img',
        '.product-detail img',
        '#prdDetail img',
        '.goods_detail img',
        '.detailArea img'
      ];

      const imageElements = new Set();
      for (const selector of imageSelectors) {
        const imgs = document.querySelectorAll(selector);
        imgs.forEach(img => imageElements.add(img));
      }

      imageElements.forEach(img => {
        const src = img.getAttribute('data-src') ||
                    img.getAttribute('data-original') ||
                    img.getAttribute('ec-data-src') ||
                    img.getAttribute('src') || '';
        if (src && !src.includes('icon') && !src.includes('badge')) {
          result.detailImages.push(src);
        }
      });

      // 3. Extract specifications (if structured)
      const specSection = document.querySelector('.spec, .specification, .product-spec, table.spec');
      if (specSection) {
        const rows = specSection.querySelectorAll('tr, .spec-row, .info-row');
        rows.forEach(row => {
          const label = row.querySelector('th, .label, .spec-label')?.textContent.trim();
          const value = row.querySelector('td, .value, .spec-value')?.textContent.trim();
          if (label && value) {
            result.specifications[label] = value;
          }
        });
      }

      // 4. Extract description text (clean)
      const descSection = document.querySelector('.description, .product-description, .prd-desc');
      if (descSection) {
        result.description = descSection.textContent.trim().replace(/\s+/g, ' ').slice(0, 500);
      } else if (result.rawText) {
        result.description = result.rawText.slice(0, 500);
      }

      // üÜï 5. Extract COLOR/STYLE options
      const colorCards = document.querySelectorAll('.color-card, .color-card-wrap .card, .plr-120 .card');
      colorCards.forEach(card => {
        const img = card.querySelector('img');
        const textElem = card.querySelector('.font-2222, .font-1818');
        if (img && textElem) {
          const text = textElem.textContent.trim();
          const lines = text.split('\n').map(l => l.trim()).filter(Boolean);

          result.styles.push({
            type: 'color',
            nameEn: lines[0] || '',
            nameKr: lines[1] || '',
            imageUrl: img.src || img.getAttribute('data-src') || ''
          });
        }
      });

      // üÜï 6. Extract SERIES information
      const seriesCards = document.querySelectorAll('.title-sm + .row .card, [class*="series"] .card');
      seriesCards.forEach(card => {
        const img = card.querySelector('img');
        const textElem = card.querySelector('.font-1818, .font-2222');
        if (img && textElem) {
          const name = textElem.textContent.trim();
          const imgSrc = img.src || img.getAttribute('data-src') || '';

          // ÏãúÎ¶¨Ï¶à Ïù¥ÎØ∏ÏßÄ URL Ìå®ÌÑ¥ Ï≤¥ÌÅ¨
          if (imgSrc.includes('series_') || name.match(/\d{4}/)) {
            result.series.push({
              name: name,
              imageUrl: imgSrc
            });
          }
        }
      });

      // üÜï 7. Extract REVIEW images
      const reviewSlides = document.querySelectorAll('.custom-review .swiper-slide img, .review-area img');
      reviewSlides.forEach(img => {
        const src = img.src || img.getAttribute('data-src') || '';
        if (src && src.includes('review_')) {
          result.reviews.push(src);
        }
      });

      return result;
    });

    // Convert relative URLs to absolute
    detailData.detailImages = [...new Set(detailData.detailImages)].map(url => {
      const abs = absoluteUrl(url, productUrl);
      return abs || url;
    });

    // Post-process HTML: replace all remaining ec-data-src and convert relative URLs
    const baseUrl = new URL(productUrl).origin;
    detailData.detailHTML = detailData.detailHTML
      // Replace ec-data-src with src
      .replace(/ec-data-src="([^"]*)"/g, 'src="$1"')
      // Replace data-src with src
      .replace(/<img([^>]*)\bdata-src="([^"]*)"/g, '<img$1src="$2"')
      // Convert relative image URLs to absolute
      .replace(/src="\/([^"]*)"/g, `src="${baseUrl}/$1"`)
      // Remove lazy-load placeholders (base64 images)
      .replace(/src="data:image[^"]*"/g, '');

    console.log(`  ‚úì Extracted:`);
    console.log(`    - HTML length: ${detailData.detailHTML.length} chars`);
    console.log(`    - Images: ${detailData.detailImages.length}`);
    console.log(`    - Specs: ${Object.keys(detailData.specifications).length} fields`);
    console.log(`    - Description: ${detailData.description.length} chars`);
    console.log(`    - üé® Styles/Colors: ${detailData.styles.length}`);
    console.log(`    - üì¶ Series: ${detailData.series.length}`);
    console.log(`    - ‚≠ê Reviews: ${detailData.reviews.length}`);

    return detailData;

  } catch (err) {
    console.error(`  ‚úó Error: ${err.message}`);
    return {
      detailHTML: '',
      detailImages: [],
      specifications: {},
      description: '',
      rawText: '',
      error: err.message
    };
  }
}

async function processCategory(browser, categoryFile, limit = null) {
  const filePath = path.join(process.cwd(), 'data', 'ÌîåÎû´Ìè¨Ïù∏Ìä∏', categoryFile);

  if (!fs.existsSync(filePath)) {
    console.error(`‚ùå File not found: ${filePath}`);
    return;
  }

  console.log(`\n${'='.repeat(60)}`);
  console.log(`üìÇ Processing: ${categoryFile}`);
  console.log(`${'='.repeat(60)}`);

  const products = JSON.parse(fs.readFileSync(filePath, 'utf8'));
  const toProcess = limit ? products.slice(0, limit) : products;

  const context = await browser.newContext({
    userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36',
    locale: 'ko-KR',
    viewport: { width: 1366, height: 768 },
    timezoneId: 'Asia/Seoul',
    extraHTTPHeaders: { 'Accept-Language': 'ko-KR,ko;q=0.9,en;q=0.8' },
  });

  // Stealth mode
  await context.addInitScript(() => {
    try {
      Object.defineProperty(navigator, 'webdriver', { get: () => false });
      Object.defineProperty(navigator, 'languages', { get: () => ['ko-KR', 'ko', 'en-US', 'en'] });
      window.chrome = { runtime: {} };
    } catch {}
  });

  const page = await context.newPage();

  for (let i = 0; i < toProcess.length; i++) {
    const product = toProcess[i];

    if (!product.productUrl) {
      console.log(`[${i+1}/${toProcess.length}] ‚è≠Ô∏è  Skipping (no URL): ${product.title}`);
      continue;
    }

    // Skip if already processed
    if (product.detailHTML && product.detailHTML.length > 0) {
      console.log(`[${i+1}/${toProcess.length}] ‚è≠Ô∏è  Skipping (already processed): ${product.title}`);
      continue;
    }

    console.log(`\n[${i+1}/${toProcess.length}] üîÑ ${product.title}`);

    const detailData = await scrapeDetailPage(page, product.productUrl);

    // Merge detail data into product
    Object.assign(product, detailData);

    // Save progress every 5 products
    if ((i + 1) % 5 === 0) {
      fs.writeFileSync(filePath, JSON.stringify(products, null, 2), 'utf8');
      console.log(`\nüíæ Progress saved (${i + 1}/${toProcess.length})`);
    }

    // Rate limiting
    await page.waitForTimeout(1500 + Math.random() * 1000);
  }

  // Final save
  fs.writeFileSync(filePath, JSON.stringify(products, null, 2), 'utf8');
  console.log(`\n‚úÖ Completed: ${categoryFile}`);
  console.log(`   Processed: ${toProcess.length} products`);

  await page.close();
  await context.close();
}

(async () => {
  const browser = await chromium.launch({
    headless: false, // Set to false to see the browser (trueÎ°ú Î≥ÄÍ≤ΩÌïòÎ©¥ Î∞±Í∑∏ÎùºÏö¥Îìú Ïã§Ìñâ)
    args: ['--no-sandbox', '--disable-setuid-sandbox']
  });

  try {
    // üöÄ Î™®Îì† ÌîåÎû´Ìè¨Ïù∏Ìä∏ Ïπ¥ÌÖåÍ≥†Î¶¨ Ï≤òÎ¶¨
    const categories = [
      'flatpoint-Ìå®Î∏åÎ¶≠ÏÜåÌåå.json',     // ‚úÖ Ïù¥ÎØ∏ ÏôÑÎ£å (78Í∞ú)
      'flatpoint-Í∞ÄÏ£ΩÏÜåÌåå.json',       // 21Í∞ú
      'flatpoint-Ï≤¥Ïñ¥.json',           // 43Í∞ú
      'flatpoint-Ï°∞Î™Ö&ÌôàÎç∞ÏΩî.json',    // 38Í∞ú
      'flatpoint-ÌÖåÏù¥Î∏î.json',         // 30Í∞ú
      'flatpoint-ÏÑ†Î∞ò.json',           // 19Í∞ú
      'flatpoint-DOB.json',            // 15Í∞ú
      'flatpoint-ÏÇ¨Ïù¥ÎìúÌÖåÏù¥Î∏î.json',   // 15Í∞ú
      'flatpoint-ÌÇ§Ï¶à.json',           // 7Í∞ú
      'flatpoint-Ïπ®ÎåÄ&Îß§Ìä∏Î¶¨Ïä§.json'   // 4Í∞ú
    ];

    console.log('\n' + '='.repeat(70));
    console.log('üéØ LUNUS - ÌîåÎû´Ìè¨Ïù∏Ìä∏ Ï†ÑÏ≤¥ Ïπ¥ÌÖåÍ≥†Î¶¨ ÏÉÅÏÑ∏ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë');
    console.log('='.repeat(70));
    console.log(`üìÇ Ï¥ù Ïπ¥ÌÖåÍ≥†Î¶¨: ${categories.length}Í∞ú`);
    console.log(`‚è±Ô∏è  ÏòàÏÉÅ ÏÜåÏöî ÏãúÍ∞Ñ: ÏïΩ 4-5ÏãúÍ∞Ñ`);
    console.log(`üíæ ÏûêÎèô Ï†ÄÏû•: 5Í∞úÎßàÎã§`);
    console.log(`üîÑ Ïû¨ÏãúÎèÑ: Ïù¥ÎØ∏ Ï≤òÎ¶¨Îêú Ï†úÌíàÏùÄ ÏûêÎèô Ïä§ÌÇµ`);
    console.log('='.repeat(70) + '\n');

    const startTime = Date.now();
    let totalProcessed = 0;
    let totalSkipped = 0;

    for (let i = 0; i < categories.length; i++) {
      const category = categories[i];

      console.log(`\n\n${'üîπ'.repeat(35)}`);
      console.log(`üì¶ Ïπ¥ÌÖåÍ≥†Î¶¨ [${i + 1}/${categories.length}]: ${category}`);
      console.log(`${'üîπ'.repeat(35)}`);

      try {
        await processCategory(browser, category, null);
        totalProcessed++;
      } catch (err) {
        console.error(`\n‚ùå Ïπ¥ÌÖåÍ≥†Î¶¨ Ï≤òÎ¶¨ Ïã§Ìå®: ${category}`);
        console.error(`   ÏóêÎü¨: ${err.message}`);
        console.log(`   ‚è© Îã§Ïùå Ïπ¥ÌÖåÍ≥†Î¶¨Î°ú Í≥ÑÏÜç ÏßÑÌñâ...\n`);
        totalSkipped++;
      }

      // Ïπ¥ÌÖåÍ≥†Î¶¨ Í∞Ñ Ïâ¨Îäî ÏãúÍ∞Ñ (ÏÑúÎ≤Ñ Î∂ÄÌïò Î∞©ÏßÄ)
      if (i < categories.length - 1) {
        console.log(`\n‚è∏Ô∏è  Îã§Ïùå Ïπ¥ÌÖåÍ≥†Î¶¨ Ï†Ñ 3Ï¥à ÎåÄÍ∏∞...\n`);
        await new Promise(resolve => setTimeout(resolve, 3000));
      }
    }

    // ÏµúÏ¢Ö Í≤∞Í≥º
    const endTime = Date.now();
    const totalMinutes = Math.round((endTime - startTime) / 1000 / 60);

    console.log('\n\n' + '='.repeat(70));
    console.log('üéâ Ï†ÑÏ≤¥ ÌÅ¨Î°§ÎßÅ ÏôÑÎ£å!');
    console.log('='.repeat(70));
    console.log(`‚úÖ Ï≤òÎ¶¨ ÏôÑÎ£å: ${totalProcessed}/${categories.length} Ïπ¥ÌÖåÍ≥†Î¶¨`);
    console.log(`‚è≠Ô∏è  Ïä§ÌÇµ: ${totalSkipped} Ïπ¥ÌÖåÍ≥†Î¶¨`);
    console.log(`‚è±Ô∏è  Ï¥ù ÏÜåÏöî ÏãúÍ∞Ñ: ${totalMinutes}Î∂Ñ`);
    console.log('='.repeat(70));
    console.log('\nüí° Îã§Ïùå Îã®Í≥Ñ:');
    console.log('   1. http://localhost:3000/test-screenshot ÏóêÏÑú Í≤∞Í≥º ÌôïÏù∏');
    console.log('   2. http://localhost:3000/products-gallery ÏóêÏÑú Í∞§Îü¨Î¶¨ ÌôïÏù∏');
    console.log('   3. Î™®Îì† Ï†úÌíàÏù¥ Î£®ÎÑàÏä§ Ïä§ÌÉÄÏùºÎ°ú ÌëúÏãúÎê©ÎãàÎã§!\n');

  } catch (err) {
    console.error('\n‚ùå Fatal error:', err);
  } finally {
    await browser.close();
  }
})();
